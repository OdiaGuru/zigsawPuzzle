<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jigsaw Puzzle</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the body and canvas */
        body {
            font-family: "Inter", sans-serif; /* Use Inter font */
            background-color: #f0f4f8; /* Light blue-gray background */
            transition: background-color 0.3s ease; /* Smooth transition for dark mode */
        }
        body.dark {
            background-color: #1a202c; /* Dark background for dark mode */
        }
        canvas {
            border: 2px solid #60a5fa; /* Blue border for the puzzle canvas */
            background-color: #e2e8f0; /* Lighter blue-gray for canvas background */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming on canvas */
        }
        body.dark canvas {
            border-color: #90cdf4; /* Lighter blue border in dark mode */
            background-color: #2d3748; /* Darker background for canvas in dark mode */
        }

        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }

        .tooltip-container .tooltip-text {
            visibility: hidden;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position the tooltip above the button */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap; /* Prevent text wrapping */
            font-size: 0.875rem; /* text-sm */
        }

        .tooltip-container .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        /* Styles for collapsable controls */
        #controlsContainer {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
            max-height: 200px; /* Max height when expanded, adjust as needed */
            opacity: 1;
        }
        #controlsContainer.collapsed {
            max-height: 0;
            opacity: 0;
            margin-bottom: 0 !important; /* Override margin when collapsed */
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <div class="bg-white p-6 rounded-lg shadow-xl max-w-4xl w-full dark:bg-gray-800 dark:text-gray-100 transition duration-300 ease-in-out">
        <!-- Controls for image upload, difficulty, and puzzle actions -->
        <div id="controlsContainer" class="flex flex-wrap items-center justify-center gap-4 mb-6">
            <!-- Upload Image Button (Icon with Tooltip) -->
            <div class="tooltip-container">
                <label for="imageUpload" class="cursor-pointer bg-blue-500 hover:bg-blue-600 text-white p-3 rounded-full shadow-md transition duration-300 ease-in-out dark:bg-blue-700 dark:hover:bg-blue-800 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-image-plus"><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7"/><line x1="16" x2="22" y1="5" y2="5"/><line x1="19" x2="19" y1="2" y2="8"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>
                </label>
                <input type="file" id="imageUpload" accept="image/*" class="hidden">
                <span class="tooltip-text">Upload Image</span>
            </div>

            <!-- Difficulty Slider -->
            <div class="flex items-center gap-2">
                <label for="difficulty" class="text-gray-700 font-medium dark:text-gray-300">Pieces:</label>
                <input type="range" id="difficulty" min="2" max="10" value="4" class="w-32 accent-blue-500 dark:accent-blue-400">
                <span id="difficultyValue" class="text-gray-800 font-bold dark:text-gray-200">4</span>
            </div>

            <!-- Create Puzzle Button (Icon with Tooltip) -->
            <div class="tooltip-container">
                <button id="createPuzzleBtn" class="bg-green-500 hover:bg-green-600 text-white p-3 rounded-full shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed dark:bg-green-700 dark:hover:bg-green-800 flex items-center justify-center" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-puzzle"><path d="M19.4 15.3c.7-.7 1.3-1.4 1.3-2.3 0-.9-.6-1.6-1.3-2.3l-1.4-1.5c-.7-.7-1.4-1.3-2.3-1.3-.9 0-1.6.6-2.3 1.3L9.7 4.6c-.7.7-1.4 1.3-2.3 1.3-.9 0-1.6-.6-2.3-1.3L3.7 3.2c-.7-.7-1.3-1.4-1.3-2.3 0-.9.6-1.6 1.3-2.3L4.6 1.3c.7-.7 1.3-1.4 1.3-2.3 0-.9-.6-1.6-1.3-2.3L3.2 3.7c-.7-.7-1.4-1.3-2.3-1.3-.9 0-1.6.6-2.3 1.3L1.3 4.6c.7-.7 1.4-1.3 2.3-1.3.9 0 1.6.6 2.3 1.3L4.6 9.7c-.7.7-1.3 1.4-1.3 2.3 0 .9.6 1.6 1.3 2.3L6 19.4c.7.7 1.4 1.3 2.3 1.3.9 0 1.6-.6 2.3-1.3l1.5-1.4c.7-.7 1.3-1.4 1.3-2.3 0-.9-.6-1.6-1.3-2.3L19.4 15.3Z"/></svg>
                </button>
                <span class="tooltip-text">Create Puzzle</span>
            </div>

            <!-- Shuffle Button (Icon with Tooltip) -->
            <div class="tooltip-container">
                <button id="shuffleBtn" class="bg-yellow-500 hover:bg-yellow-600 text-white p-3 rounded-full shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed dark:bg-yellow-700 dark:hover:bg-yellow-800 flex items-center justify-center" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-shuffle"><path d="M2 18h10a4 4 0 0 0 4-4V8a4 4 0 0 1 4-4h2"/><path d="M7 21v-3h3"/><path d="M17 3v3h3"/><path d="M2 6h10a4 4 0 0 1 4 4v4a4 4 0 0 0 4 4h2"/></svg>
                </button>
                <span class="tooltip-text">Shuffle Puzzle</span>
            </div>

            <!-- Solve Button (Icon with Tooltip) -->
            <div class="tooltip-container">
                <button id="solveBtn" class="bg-purple-500 hover:bg-purple-600 text-white p-3 rounded-full shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed dark:bg-purple-700 dark:hover:bg-purple-800 flex items-center justify-center" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-check-circle"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="m9 11 3 3L22 4"/></svg>
                </button>
                <span class="tooltip-text">Solve Puzzle</span>
            </div>

            <!-- Fullscreen Toggle Button (Icon with Tooltip) -->
            <div class="tooltip-container">
                <button id="fullscreenToggle" class="bg-indigo-500 hover:bg-indigo-600 text-white p-3 rounded-full shadow-md transition duration-300 ease-in-out dark:bg-indigo-700 dark:hover:bg-indigo-800 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M16 3h3a2 2 0 0 1 2 2v3"/><path d="M8 21H5a2 2 0 0 1-2-2v-3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg>
                </button>
                <span class="tooltip-text">Toggle Fullscreen</span>
            </div>

            <!-- Dark Mode Toggle Button (Icon with Tooltip) -->
            <div class="tooltip-container">
                <button id="darkModeToggle" class="bg-gray-300 hover:bg-gray-400 text-gray-800 p-3 rounded-full shadow-md transition duration-300 ease-in-out dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-100 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon-star"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/><path d="M19 3v4"/><path d="M21 5h-4"/></svg>
                </button>
                <span class="tooltip-text">Toggle Dark Mode</span>
            </div>
        </div>

        <!-- Toggle Controls Button (outside controlsContainer for persistent visibility) -->
        <div class="tooltip-container mb-4">
            <button id="toggleControlsBtn" class="bg-gray-400 hover:bg-gray-500 text-white p-3 rounded-full shadow-md transition duration-300 ease-in-out dark:bg-gray-600 dark:hover:bg-gray-500 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevrons-up-down"><path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/></svg>
            </button>
            <span class="tooltip-text">Toggle Controls</span>
        </div>

        <!-- Puzzle Canvas Container -->
        <div id="puzzleContainer" class="relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg">
            <canvas id="puzzleCanvas" class="w-full h-full block"></canvas>
            <!-- Completion Message Overlay -->
            <div id="completionMessage" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 text-white text-4xl font-bold rounded-lg hidden">
                Puzzle Solved! ðŸŽ‰
            </div>
        </div>

        <!-- Hidden Canvas for image processing -->
        <canvas id="hiddenCanvas" class="hidden"></canvas>
    </div>

    <script>
        // Get references to DOM elements
        const imageUpload = document.getElementById('imageUpload');
        const difficultySlider = document.getElementById('difficulty');
        const difficultyValueSpan = document.getElementById('difficultyValue');
        const createPuzzleBtn = document.getElementById('createPuzzleBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const solveBtn = document.getElementById('solveBtn');
        const puzzleCanvas = document.getElementById('puzzleCanvas');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const completionMessage = document.getElementById('completionMessage');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const fullscreenToggle = document.getElementById('fullscreenToggle');
        const puzzleContainer = document.getElementById('puzzleContainer');
        const toggleControlsBtn = document.getElementById('toggleControlsBtn'); // New button for controls
        const controlsContainer = document.getElementById('controlsContainer'); // Container for controls
        const body = document.body;

        // Get 2D rendering contexts for both canvases
        const ctx = puzzleCanvas.getContext('2d');
        const hiddenCtx = hiddenCanvas.getContext('2d');

        // Global variables for puzzle state
        let originalImage = new Image(); // Stores the uploaded image
        let puzzlePieces = []; // Array to hold puzzle piece objects
        let numRowsCols = parseInt(difficultySlider.value); // Number of rows/columns for the grid
        let pieceWidth, pieceHeight; // Dimensions of each puzzle piece
        let puzzleWidth, puzzleHeight; // Dimensions of the main puzzle area

        let draggingPiece = null; // Stores the piece currently being dragged
        let offsetX, offsetY; // Offset from mouse/touch to piece's top-left corner
        let currentZIndex = 0; // Used to ensure the dragging piece is drawn on top

        // --- Dark Mode Logic ---
        /**
         * Toggles dark mode on and off.
         * Stores the preference in localStorage.
         */
        function toggleDarkMode() {
            body.classList.toggle('dark');
            if (body.classList.contains('dark')) {
                localStorage.setItem('theme', 'dark');
            } else {
                localStorage.setItem('theme', 'light');
            }
            drawPuzzle(); // Redraw canvas to update borders if needed
        }

        /**
         * Applies the saved theme preference on page load.
         */
        function applyTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                body.classList.add('dark');
            }
        }

        // Apply theme on initial load
        applyTheme();
        darkModeToggle.addEventListener('click', toggleDarkMode);

        // --- Fullscreen Logic ---
        /**
         * Toggles fullscreen mode for the puzzle container.
         */
        fullscreenToggle.addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                puzzleContainer.requestFullscreen().catch(err => {
                    showTemporaryMessage(`Error attempting to enable full-screen mode: ${err.message} (Your browser may block it)`, "bg-red-500");
                });
            }
        });

        // Event listener for fullscreen change to update UI if needed (not strictly necessary for this app)
        document.addEventListener('fullscreenchange', () => {
            // You could change the fullscreen icon here if desired
        });

        // --- Toggle Controls Logic ---
        /**
         * Toggles the visibility of the controls container.
         */
        toggleControlsBtn.addEventListener('click', () => {
            controlsContainer.classList.toggle('collapsed');
            // Change icon based on state
            const icon = toggleControlsBtn.querySelector('svg');
            if (controlsContainer.classList.contains('collapsed')) {
                icon.innerHTML = '<path d="m6 9 6 6 6-6"/>'; // Chevron down
                toggleControlsBtn.closest('.tooltip-container').querySelector('.tooltip-text').textContent = 'Show Controls';
            } else {
                icon.innerHTML = '<path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/>'; // Chevrons up-down
                toggleControlsBtn.closest('.tooltip-container').querySelector('.tooltip-text').textContent = 'Toggle Controls';
            }
        });


        // --- Event Listeners ---

        /**
         * Handles the image file upload.
         * Reads the file, loads it into an Image object, and prepares canvases.
         */
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    originalImage.onload = () => {
                        // Calculate aspect ratio
                        const aspectRatio = originalImage.width / originalImage.height;
                        const MAX_DIMENSION = 600; // Max width/height for the puzzle canvas

                        if (originalImage.width > originalImage.height) { // Landscape or square
                            puzzleWidth = MAX_DIMENSION;
                            puzzleHeight = MAX_DIMENSION / aspectRatio;
                        } else { // Portrait
                            puzzleHeight = MAX_DIMENSION;
                            puzzleWidth = MAX_DIMENSION * aspectRatio;
                        }

                        // Set main puzzle canvas dimensions
                        puzzleCanvas.width = puzzleWidth;
                        puzzleCanvas.height = puzzleHeight;

                        // Set hidden canvas dimensions to match original image for accurate cutting
                        hiddenCanvas.width = originalImage.width;
                        hiddenCanvas.height = originalImage.height;

                        // Draw the original image onto the hidden canvas
                        hiddenCtx.drawImage(originalImage, 0, 0);

                        // Enable relevant buttons and hide completion message
                        createPuzzleBtn.disabled = false;
                        shuffleBtn.disabled = true;
                        solveBtn.disabled = true;
                        completionMessage.classList.add('hidden');
                        drawPuzzle(); // Clear canvas or show placeholder
                    };
                    originalImage.src = event.target.result; // Set image source from file reader
                };
                reader.readAsDataURL(file); // Read the file as a data URL
            }
        });

        /**
         * Updates the displayed difficulty value when the slider is moved.
         * Enables the 'Create Puzzle' button if an image is already loaded.
         */
        difficultySlider.addEventListener('input', (e) => {
            numRowsCols = parseInt(e.target.value);
            difficultyValueSpan.textContent = numRowsCols;
            if (originalImage.src) {
                createPuzzleBtn.disabled = false;
            }
        });

        /**
         * Triggers puzzle creation when the 'Create Puzzle' button is clicked.
         * Shows a message if no image is uploaded.
         */
        createPuzzleBtn.addEventListener('click', () => {
            if (!originalImage.src) {
                // Display a custom message instead of alert
                showTemporaryMessage("Please upload an image first!", "bg-red-500");
                return;
            }
            createPuzzle();
            shuffleBtn.disabled = false;
            solveBtn.disabled = false;
            completionMessage.classList.add('hidden');
        });

        /**
         * Triggers puzzle shuffling when the 'Shuffle' button is clicked.
         * Shows a message if no puzzle has been created.
         */
        shuffleBtn.addEventListener('click', () => {
            if (puzzlePieces.length === 0) {
                // Display a custom message instead of alert
                showTemporaryMessage("Please create a puzzle first!", "bg-red-500");
                return;
            }
            shufflePieces();
            completionMessage.classList.add('hidden');
        });

        /**
         * Triggers puzzle solving when the 'Solve' button is clicked.
         * Shows a message if no puzzle has been created.
         */
        solveBtn.addEventListener('click', () => {
            if (puzzlePieces.length === 0) {
                // Display a custom message instead of alert
                showTemporaryMessage("Please create a puzzle first!", "bg-red-500");
                return;
            }
            solvePuzzle();
            completionMessage.classList.add('hidden');
        });

        // --- Custom Message Box (replaces alert) ---
        /**
         * Displays a temporary message on the screen.
         * @param {string} message - The message to display.
         * @param {string} bgColorClass - Tailwind background color class (e.g., 'bg-red-500').
         */
        function showTemporaryMessage(message, bgColorClass) {
            let messageBox = document.getElementById('tempMessageBox');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'tempMessageBox';
                messageBox.className = 'fixed top-4 left-1/2 -translate-x-1/2 p-3 rounded-lg text-white font-semibold shadow-lg z-50 transition-all duration-300 ease-out opacity-0';
                document.body.appendChild(messageBox);
            }

            messageBox.textContent = message;
            messageBox.className = `fixed top-4 left-1/2 -translate-x-1/2 p-3 rounded-lg text-white font-semibold shadow-lg z-50 transition-all duration-300 ease-out ${bgColorClass} opacity-100`;

            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                messageBox.classList.add('opacity-0');
            }, 3000); // Message disappears after 3 seconds
        }

        // --- Puzzle Core Logic ---

        /**
         * Divides the loaded image into rectangular puzzle pieces.
         * Each piece's image data is extracted and stored as a Data URL, and an Image object is created for it.
         */
        function createPuzzle() {
            puzzlePieces = []; // Clear existing pieces
            pieceWidth = puzzleWidth / numRowsCols;
            pieceHeight = puzzleHeight / numRowsCols;

            // Calculate scaling factors to map original image dimensions to puzzle canvas dimensions
            // These ratios are now based on the *display* dimensions of the puzzleCanvas
            const sourceXRatio = originalImage.width / puzzleCanvas.width;
            const sourceYRatio = originalImage.height / puzzleCanvas.height;

            const piecePromises = []; // To track when all piece images are loaded

            for (let row = 0; row < numRowsCols; row++) {
                for (let col = 0; col < numRowsCols; col++) {
                    const originalX = col * pieceWidth;
                    const originalY = row * pieceHeight;

                    // Calculate source coordinates and dimensions from the original image
                    // These are based on the *original image's* dimensions scaled by the ratios
                    const sourceX = originalX * sourceXRatio;
                    const sourceY = originalY * sourceYRatio;
                    const sourceWidth = pieceWidth * sourceXRatio;
                    const sourceHeight = pieceHeight * sourceYRatio;

                    // Create a temporary canvas for each piece to extract its image data
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = pieceWidth;
                    tempCanvas.height = pieceHeight;
                    const tempCtx = tempCanvas.getContext('2d');

                    // Draw the specific part of the original image onto the temporary canvas
                    tempCtx.drawImage(
                        originalImage,
                        sourceX, sourceY, sourceWidth, sourceHeight, // Source rectangle on original image
                        0, 0, pieceWidth, pieceHeight // Destination rectangle on temp canvas
                    );

                    const pieceImg = new Image();
                    pieceImg.src = tempCanvas.toDataURL(); // Set image source to the piece's Data URL

                    const piece = {
                        id: `piece-${row}-${col}`, // Unique ID for the piece
                        originalX: originalX,      // Correct X position
                        originalY: originalY,      // Correct Y position
                        currentX: originalX,       // Current X position (initially correct)
                        currentY: originalY,       // Current Y position (initially correct)
                        image: pieceImg,           // Store the Image object directly
                        zIndex: 0                  // Initial z-index for drawing order
                    };
                    puzzlePieces.push(piece);

                    // Create a promise that resolves when this piece's image is loaded
                    piecePromises.push(new Promise(resolve => {
                        pieceImg.onload = resolve;
                        pieceImg.onerror = () => {
                            console.error(`Failed to load piece image for ${piece.id}`);
                            resolve(); // Resolve even on error to not block Promise.all
                        };
                    }));
                }
            }

            // Wait for all piece images to load before drawing the puzzle
            Promise.all(piecePromises).then(() => {
                drawPuzzle(); // Draw the newly created puzzle
            });
        }

        /**
         * Randomly shuffles the positions of all puzzle pieces.
         */
        function shufflePieces() {
            // Create an array of all possible target positions
            const positions = [];
            for (let row = 0; row < numRowsCols; row++) {
                for (let col = 0; col < numRowsCols; col++) {
                    positions.push({ x: col * pieceWidth, y: row * pieceHeight });
                }
            }

            // Fisher-Yates (Knuth) shuffle algorithm for positions
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]]; // Swap elements
            }

            // Assign the shuffled positions to each puzzle piece
            puzzlePieces.forEach((piece, index) => {
                piece.currentX = positions[index].x;
                piece.currentY = positions[index].y;
                piece.zIndex = 0; // Reset z-index after shuffling
            });
            drawPuzzle(); // Redraw the puzzle with new positions
        }

        /**
         * Moves all puzzle pieces back to their original, solved positions.
         */
        function solvePuzzle() {
            puzzlePieces.forEach(piece => {
                piece.currentX = piece.originalX;
                piece.currentY = piece.originalY;
                piece.zIndex = 0; // Reset z-index
            });
            drawPuzzle(); // Redraw the solved puzzle
            checkCompletion(); // Check completion immediately after solving
        }

        /**
         * Clears the main puzzle canvas and redraws all puzzle pieces at their current positions.
         * Pieces are sorted by zIndex to ensure correct drawing order (dragging piece on top).
         * This function now uses pre-loaded Image objects, reducing flickering.
         */
        function drawPuzzle() {
            ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height); // Clear the entire canvas

            // Sort pieces by zIndex to draw pieces with higher zIndex on top
            puzzlePieces.sort((a, b) => a.zIndex - b.zIndex);

            puzzlePieces.forEach(piece => {
                // Use the pre-loaded Image object directly
                ctx.drawImage(piece.image, piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                // Draw a subtle border around each piece for visual separation
                ctx.strokeStyle = body.classList.contains('dark') ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.2)'; // Border color adapts to dark mode
                ctx.lineWidth = 1;
                ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
            });
        }

        // --- Drag and Drop Logic (Mouse and Touch) ---

        // Mouse event listeners
        puzzleCanvas.addEventListener('mousedown', handleMouseDown);
        puzzleCanvas.addEventListener('mousemove', handleMouseMove);
        puzzleCanvas.addEventListener('mouseup', handleMouseUp);
        puzzleCanvas.addEventListener('mouseout', handleMouseUp); // End drag if mouse leaves canvas

        // Touch event listeners (passive: false to allow preventDefault)
        puzzleCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        puzzleCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        puzzleCanvas.addEventListener('touchend', handleTouchEnd);
        puzzleCanvas.addEventListener('touchcancel', handleTouchEnd); // Handle touch interruption

        /**
         * Gets the coordinates of the mouse or touch event relative to the canvas.
         * @param {Event} e - The mouse or touch event.
         * @returns {{x: number, y: number}} - Object with x and y coordinates.
         */
        function getEventCoords(e) {
            const rect = puzzleCanvas.getBoundingClientRect(); // Get canvas position and size
            let clientX, clientY;

            // Check if it's a touch event
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else { // It's a mouse event
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // Calculate coordinates relative to the canvas
            // Adjust for canvas scaling if CSS width/height differ from canvas.width/height
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        /** Mouse event handlers */
        function handleMouseDown(e) {
            e.preventDefault(); // Prevent default browser actions (e.g., text selection)
            const coords = getEventCoords(e);
            startDrag(coords.x, coords.y);
        }

        function handleMouseMove(e) {
            e.preventDefault();
            const coords = getEventCoords(e);
            drag(coords.x, coords.y);
        }

        function handleMouseUp(e) {
            e.preventDefault();
            endDrag();
        }

        /** Touch event handlers */
        function handleTouchStart(e) {
            e.preventDefault(); // Prevent scrolling/zooming on touch
            const coords = getEventCoords(e);
            startDrag(coords.x, coords.y);
        }

        function handleTouchMove(e) {
            e.preventDefault(); // Prevent scrolling/zooming on touch
            const coords = getEventCoords(e);
            drag(coords.x, coords.y);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            endDrag();
        }

        /**
         * Initiates the drag operation.
         * Finds the puzzle piece under the mouse/touch coordinates and sets it as the dragging piece.
         * Updates its z-index to bring it to the front.
         * @param {number} mouseX - X coordinate of the mouse/touch.
         * @param {number} mouseY - Y coordinate of the mouse/touch.
         */
        function startDrag(mouseX, mouseY) {
            // Iterate through pieces from top (highest z-index) to bottom to find the clicked piece
            for (let i = puzzlePieces.length - 1; i >= 0; i--) {
                const piece = puzzlePieces[i];
                // Check if mouse/touch coordinates are within the piece's bounds
                if (mouseX >= piece.currentX && mouseX <= piece.currentX + pieceWidth &&
                    mouseY >= piece.currentY && mouseY <= piece.currentY + pieceHeight) {
                    draggingPiece = piece; // Set this piece as the one being dragged
                    offsetX = mouseX - piece.currentX; // Calculate offset from piece's top-left
                    offsetY = mouseY - piece.currentY;

                    // Bring the dragging piece to the top by incrementing its zIndex
                    currentZIndex++;
                    draggingPiece.zIndex = currentZIndex;
                    drawPuzzle(); // Redraw the puzzle to show the piece on top
                    return; // Stop after finding the first piece
                }
            }
        }

        /**
         * Updates the position of the dragging piece.
         * @param {number} mouseX - Current X coordinate of the mouse/touch.
         * @param {number} mouseY - Current Y coordinate of the mouse/touch.
         */
        function drag(mouseX, mouseY) {
            if (draggingPiece) {
                // Update piece's current position based on mouse/touch and initial offset
                draggingPiece.currentX = mouseX - offsetX;
                draggingPiece.currentY = mouseY - offsetY;
                drawPuzzle(); // Redraw the puzzle to reflect the piece's new position
            }
        }

        const SNAP_THRESHOLD = 20; // Pixels: if a piece is within this distance of its correct spot, it snaps.

        /**
         * Ends the drag operation.
         * Checks if the dropped piece is close enough to its original position to snap into place.
         * Triggers a completion check after the piece is dropped.
         */
        function endDrag() {
            if (draggingPiece) {
                // Calculate target coordinates (original position)
                const targetX = draggingPiece.originalX;
                const targetY = draggingPiece.originalY;

                // Calculate distance from current position to target position
                const distanceX = Math.abs(draggingPiece.currentX - targetX);
                const distanceY = Math.abs(draggingPiece.currentY - targetY);

                // If within snap threshold, snap the piece to its correct position
                if (distanceX < SNAP_THRESHOLD && distanceY < SNAP_THRESHOLD) {
                    draggingPiece.currentX = targetX;
                    draggingPiece.currentY = targetY;
                }
                draggingPiece = null; // Clear the dragging piece
                drawPuzzle(); // Redraw after potential snap
                checkCompletion(); // Check if the puzzle is solved
            }
        }

        /**
         * Checks if all puzzle pieces are in their correct original positions.
         * Displays a "Puzzle Solved!" message if completed.
         */
        function checkCompletion() {
            const allInPlace = puzzlePieces.every(piece =>
                // Check if current position is very close to original position (allowing for minor floating point errors)
                Math.abs(piece.currentX - piece.originalX) < 1 &&
                Math.abs(piece.currentY - piece.originalY) < 1
            );

            if (allInPlace) {
                completionMessage.classList.remove('hidden'); // Show completion message
                shuffleBtn.disabled = true; // Disable shuffle after completion
                solveBtn.disabled = true; // Disable solve after completion
            } else {
                completionMessage.classList.add('hidden'); // Hide completion message
            }
        }

        // Initial call to draw the puzzle (will be an empty canvas or placeholder initially)
        drawPuzzle();
    </script>
</body>
</html>
